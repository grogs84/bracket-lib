import "./chunk-5WRI5ZAA.js";

// node_modules/@mgi/bracket-core/dist/index.js
function buildLayout(input, opts = {}) {
  const hGap = opts.hGap ?? 160;
  const vGap = opts.vGap ?? 80;
  const matchesById = /* @__PURE__ */ new Map();
  for (const m of input.matches) {
    if (matchesById.has(m.id)) {
      throw new Error(`Duplicate match id: ${m.id}`);
    }
    matchesById.set(m.id, m);
  }
  if (matchesById.size === 0) {
    return { nodes: [], edges: [], rounds: [] };
  }
  const roots = input.matches.filter((m) => m.winnerNextMatchId === null);
  if (roots.length !== 1) {
    throw new Error(
      `Expected exactly 1 finals (winnerNextMatchId === null), got ${roots.length}`
    );
  }
  const root = roots[0];
  const children = /* @__PURE__ */ new Map();
  for (const m of input.matches) {
    const p = m.winnerNextMatchId;
    if (p !== null) {
      const arr = children.get(p) ?? [];
      arr.push(m);
      children.set(p, arr);
    }
  }
  for (const [k, arr] of children) {
    arr.sort((a, b) => a.id < b.id ? -1 : a.id > b.id ? 1 : 0);
    children.set(k, arr);
  }
  const depthById = /* @__PURE__ */ new Map();
  const yRowById = /* @__PURE__ */ new Map();
  const edges = [];
  let nextLeafRow = 0;
  function dfsAssign(node, depth) {
    depthById.set(node.id, depth);
    const kids = children.get(node.id) ?? [];
    if (kids.length === 0) {
      const row = nextLeafRow++;
      yRowById.set(node.id, row);
      return row;
    }
    const childRows = [];
    for (const child of kids) {
      edges.push({ from: child.id, to: node.id, kind: "winner" });
      const r = dfsAssign(child, depth + 1);
      childRows.push(r);
    }
    const minR = Math.min(...childRows);
    const maxR = Math.max(...childRows);
    const myRow = (minR + maxR) / 2;
    yRowById.set(node.id, myRow);
    return myRow;
  }
  dfsAssign(root, 0);
  let maxDepth = 0;
  for (const d of depthById.values()) maxDepth = Math.max(maxDepth, d);
  const nodes = [];
  for (const [id, depth] of depthById) {
    const round = maxDepth - depth;
    const row = yRowById.get(id);
    nodes.push({
      id,
      x: round * hGap,
      y: row * vGap,
      round
    });
  }
  nodes.sort(
    (a, b) => a.round !== b.round ? a.round - b.round : a.y !== b.y ? a.y - b.y : a.id.localeCompare(b.id)
  );
  const rounds = Array.from({ length: maxDepth + 1 }, () => []);
  for (const n of nodes) {
    rounds[n.round].push(n.id);
  }
  return { nodes, edges, rounds };
}
export {
  buildLayout
};
//# sourceMappingURL=@mgi_bracket-core.js.map
